---
title: Provider
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import todo from "!!raw-loader!/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider/todo.dart";
import completedTodos from "!!raw-loader!/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider/completed_todos.dart";
import todosConsumer from "!!raw-loader!/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider/todos_consumer.dart";
import unoptimizedPreviousButton from "!!raw-loader!/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider/unoptimized_previous_button.dart";
import optimizedPreviousButton from "!!raw-loader!/i18n/ko/docusaurus-plugin-content-docs/current/providers/provider/optimized_previous_button.dart";
import { trimSnippet } from "../../../../../src/components/CodeSnippet";

`Provider`는 프로바이더들 중 가장 기본입니다. 프로바이더는 값을 생성하고... 그게 다입니다.

`Provider` 일반적으로 아래와 같은 상황에서 사용됩니다.

- 계산 결과를 캐싱할 때
- `Repository`나 `HttpClient`와 같은 다른 프로바이더에 값을 노출할 때
- 테스트나 위젯이 값을 덮어쓸 수 있도록 할 때
- `select`를 사용하지 않고 프로바이더나 위젯의 리빌드를 줄이고자 할 때

## `Provider`를 사용하여 계산 결과를 캐싱하는 경우

`Provider`는 [ref.watch]와 같이 사용할 때 동기식 작업을 캐싱하는 강력한 도구입니다.

예를 들면, to-do 목록을 필터링 한다고 가정합시다.
목록을 필터링 할 때 약간의 비용이 들 수 있으므로, 어플리케이션이 다시 렌더링 될 때마다 to-do 목록을 필터링하지 않는 것이 이상적입니다.
이 상황에서는 `Provider`를 사용해서 필터링을 수행할 수 있습니다.

이를 위해 어플리케이션에 to-do 목록을 변경할 수 있도록 작성된 [StateNotifierProvider]가 있다고 가정합시다.

<CodeBlock>{trimSnippet(todo)}</CodeBlock>

이제 우리는 `Provider`를 사용하여 필터링된 할 일 목록을 노출하여 완료된 to-do만 표시할 수 있습니다.

<CodeBlock>{trimSnippet(completedTodos)}</CodeBlock>

이 코드를 통해 이제 UI는 `completeTodosProvider`를 구독해서 완료된 to-do 목록을 표시할 수 있습니다:

<CodeBlock>{trimSnippet(todosConsumer)}</CodeBlock>

흥미로운 점은 목록 필터링이 이제 캐시된다는 점입니다.

즉, 완료된 to-do 목록을 여러 번 읽더라도 to-do가 추가/제거/업데이트될 때까지 완료된 to-do 목록이 다시 계산되지 않습니다.

할 일 목록이 변경될 때 캐시를 수동으로 무효화할 필요가 없다는 점에 주목하세요. `Provider`는 [ref.watch] 덕분에 언제 결과를 다시 계산해야 하는지를 별도의 과정 없이 알 수 있습니다.

## `Provider`를 사용하여 공급자/위젯 리빌드 줄이기

`Provider`의 독특한 측면은 `Provider`가 다시 계산되더라도(일반적으로 [ref.watch]를 사용할 때) 값이 변경되지 않는 한 이를 구독하는 위젯/provider를 업데이트하지 않는다는 점입니다.

예를 들면 페이지네이션이 적용된 보기의 이전/다음 버튼을 활성화/비활성화할 수 있습니다:

![stepper example](https://user-images.githubusercontent.com/134939/47580830-31263a00-d950-11e8-9b61-0eaddab2709e.png)

여기서는 특히 "이전" 버튼에 집중하겠습니다.
이러한 버튼을 단순하게 구현하자면, 현재 페이지 인덱스를 가져오는 위젯이며, 해당 인덱스가 0이면 버튼을 비활성화합니다.

이 코드는 아래처럼 작성할 수 있습니다:

<CodeBlock>{trimSnippet(unoptimizedPreviousButton)}</CodeBlock>

이 코드의 문제점은 현재 페이지를 변경할 때마다 "이전" 버튼이 다시 빌드된다는 것입니다.  
하지만 활성화와 비활성화 사이를 변경할 때만 버튼이 다시 빌드되는 것이 이상적입니다.

이 문제의 원인은 사용자가 '이전' 버튼 내에서 바로 이전 페이지로 이동할 수 있는지 여부를 계산한다는 것입니다.

이 문제를 해결하는 방법은 이 로직을 위젯 외부의 `Provider`로 추출하는 것입니다:

<CodeBlock>{trimSnippet(optimizedPreviousButton)}</CodeBlock>

간단한 리팩터링을 통해 `PreviousButton` 위젯은 `Provider` 덕분에 페이지 인덱스가 변경되더라도 더 이상 다시 빌드되지 않습니다.

이제부터는 페이지 인덱스가 변경될 때 `canGoToPreviousPageProvider` 라는 provider에서 다시 계산합니다. 그러나 provider가 노출한 값이 변경되지 않으면 `PreviousButton`은 다시 빌드되지 않습니다.

이를 통해 버튼의 성능이 향상되고 위젯 외부에서 로직을 추출할 수 있다는 이점이 있습니다.

[ref.watch]: ../concepts/reading#using-refwatch-to-observe-a-provider
[statenotifierprovider]: ./state_notifier_provider
